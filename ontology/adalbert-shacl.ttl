# =============================================================================
# Adalbert SHACL Shapes
# Version: 0.2
# Date: 2026-02-03
# =============================================================================
# Validation shapes for Adalbert policies.
# =============================================================================

@prefix adalbert:    <https://vocabulary.bigbank/adalbert/> .
@prefix adalbertsh:  <https://vocabulary.bigbank/adalbert/shapes/> .
@prefix odrl:    <http://www.w3.org/ns/odrl/2/> .
@prefix sh:      <http://www.w3.org/ns/shacl#> .
@prefix xsd:     <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:    <http://www.w3.org/2000/01/rdf-schema#> .

# =============================================================================
# POLICY SHAPES
# =============================================================================

adalbertsh:PolicyShape a sh:NodeShape ;
    sh:targetClass adalbert:Policy ;
    sh:name "Policy Shape" ;
    
    sh:property [
        sh:path adalbert:clause ;
        sh:minCount 1 ;
        sh:message "Policy must have at least one clause."
    ] ;
    
    sh:property [
        sh:path adalbert:condition ;
        sh:maxCount 1 ;
        sh:node adalbertsh:ConditionShape
    ] ;
    
    sh:property [
        sh:path adalbert:target ;
        sh:class adalbert:Asset
    ] .

adalbertsh:SetShape a sh:NodeShape ;
    sh:targetClass adalbert:Set ;
    sh:name "Set Shape" ;
    
    # Set should NOT have grantor/grantee
    sh:property [
        sh:path adalbert:grantor ;
        sh:maxCount 0 ;
        sh:message "Set should not have grantor. Use Offer or Agreement."
    ] ;
    
    sh:property [
        sh:path adalbert:grantee ;
        sh:maxCount 0 ;
        sh:message "Set should not have grantee. Use Offer or Agreement."
    ] .

adalbertsh:OfferShape a sh:NodeShape ;
    sh:targetClass adalbert:Offer ;
    sh:name "Offer Shape" ;
    
    # Offer requires grantor
    sh:property [
        sh:path adalbert:grantor ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:class adalbert:Agent ;
        sh:message "Offer must have exactly one grantor."
    ] ;
    
    # Grantee optional (open offer)
    sh:property [
        sh:path adalbert:grantee ;
        sh:maxCount 1 ;
        sh:class adalbert:Agent
    ] .

adalbertsh:AgreementShape a sh:NodeShape ;
    sh:targetClass adalbert:Agreement ;
    sh:name "Agreement Shape" ;
    
    sh:property [
        sh:path adalbert:grantor ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:class adalbert:Agent ;
        sh:message "Agreement must have exactly one grantor."
    ] ;
    
    sh:property [
        sh:path adalbert:grantee ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:class adalbert:Agent ;
        sh:message "Agreement must have exactly one grantee."
    ] .

# =============================================================================
# NORM SHAPES
# =============================================================================

adalbertsh:NormShape a sh:NodeShape ;
    sh:targetClass adalbert:Norm ;
    sh:name "Norm Shape" ;
    
    sh:property [
        sh:path adalbert:subject ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:class adalbert:Agent ;
        sh:message "Norm must have exactly one subject."
    ] ;
    
    sh:property [
        sh:path adalbert:action ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:class adalbert:Action ;
        sh:message "Norm must have exactly one action."
    ] ;
    
    sh:property [
        sh:path adalbert:object ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:class adalbert:Asset ;
        sh:message "Norm must have exactly one object."
    ] ;
    
    sh:property [
        sh:path adalbert:condition ;
        sh:maxCount 1 ;
        sh:node adalbertsh:ConditionShape
    ] .

adalbertsh:DutyShape a sh:NodeShape ;
    sh:targetClass adalbert:Duty ;
    sh:name "Duty Shape" ;
    
    sh:property [
        sh:path adalbert:deadline ;
        sh:maxCount 1 ;
        sh:or (
            [ sh:datatype xsd:dateTime ]
            [ sh:datatype xsd:duration ]
        ) ;
        sh:message "Deadline must be xsd:dateTime or xsd:duration."
    ] ;
    
    sh:property [
        sh:path adalbert:dutyState ;
        sh:maxCount 1 ;
        sh:in (adalbert:Pending adalbert:Active adalbert:Fulfilled adalbert:Violated) ;
        sh:message "Duty state must be Pending, Active, Fulfilled, or Violated."
    ] .

# =============================================================================
# CONDITION SHAPES
# =============================================================================

adalbertsh:ConditionShape a sh:NodeShape ;
    sh:name "Condition Shape" ;
    
    sh:or (
        [ sh:class adalbert:AtomicConstraint ]
        [ sh:class adalbert:LogicalConstraint ]
    ) ;
    sh:message "Condition must be AtomicConstraint or LogicalConstraint." .

adalbertsh:AtomicConstraintShape a sh:NodeShape ;
    sh:targetClass adalbert:AtomicConstraint ;
    sh:name "Atomic Constraint Shape" ;
    
    sh:property [
        sh:path adalbert:leftOperand ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:class adalbert:LeftOperand ;
        sh:message "AtomicConstraint must have exactly one leftOperand."
    ] ;
    
    sh:property [
        sh:path adalbert:constraintOperator ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:class adalbert:ComparisonOperator ;
        sh:message "AtomicConstraint must have exactly one comparison operator."
    ] ;
    
    # Must have rightOperand OR rightOperandRef
    sh:xone (
        [ sh:property [ sh:path adalbert:rightOperand ; sh:minCount 1 ] ]
        [ sh:property [ sh:path adalbert:rightOperandRef ; sh:minCount 1 ] ]
    ) ;
    sh:message "AtomicConstraint must have exactly one of: rightOperand or rightOperandRef." .

adalbertsh:LogicalConstraintShape a sh:NodeShape ;
    sh:targetClass adalbert:LogicalConstraint ;
    sh:name "Logical Constraint Shape" ;
    
    sh:property [
        sh:path adalbert:constraintOperator ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:class adalbert:LogicalOperator ;
        sh:message "LogicalConstraint must have exactly one logical operator."
    ] ;
    
    sh:property [
        sh:path adalbert:operand ;
        sh:minCount 1 ;
        sh:node adalbertsh:ConditionShape ;
        sh:message "LogicalConstraint must have at least one operand."
    ] .

adalbertsh:NotConstraintShape a sh:NodeShape ;
    sh:target [
        a sh:SPARQLTarget ;
        sh:select """
            PREFIX adalbert: <https://vocabulary.bigbank/adalbert/>
            SELECT ?this WHERE {
                ?this a adalbert:LogicalConstraint ;
                      adalbert:constraintOperator adalbert:not .
            }
        """
    ] ;
    sh:name "Not Constraint Shape" ;
    
    sh:property [
        sh:path adalbert:operand ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "Not constraint must have exactly one operand."
    ] .

# =============================================================================
# REJECT UNSUPPORTED CONSTRUCTS
# =============================================================================

adalbertsh:RejectXoneShape a sh:NodeShape ;
    sh:target [
        a sh:SPARQLTarget ;
        sh:select """
            PREFIX adalbert: <https://vocabulary.bigbank/adalbert/>
            PREFIX odrl: <http://www.w3.org/ns/odrl/2/>
            SELECT ?this WHERE {
                { ?this adalbert:constraintOperator adalbert:xone }
                UNION
                { ?this odrl:operator odrl:xone }
            }
        """
    ] ;
    sh:severity sh:Violation ;
    sh:message "Adalbert does not support xone operator." .

# =============================================================================
# END OF SHAPES
# =============================================================================
